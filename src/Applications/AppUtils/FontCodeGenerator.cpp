#include "stdafx.h"

#include "FontCodeGenerator.h"
#include <Core/Log.h>
#include <Core/For.h>
#include <Core/StringUtils.h>
#include <Core/WinUtils.h>
#include <Image/BitMapFont.h>
#include <ObjectScript/Reader.h>
#include <Reflection/ObjectDatabase.h>
#include <iomanip>
#include <sstream>
#include <unordered_map>

#if SG_ENABLE_TOOLS

namespace sg {
namespace image {
namespace tool {
//=============================================================================
REFLECTION_TYPE_BEGIN((sg,image,tool), Glyph)
    REFLECTION_TYPE_DOC("")
    REFLECTION_PROPERTY_DOC(character, "")
    REFLECTION_PROPERTY_DOC(symbol, "")
    REFLECTION_PROPERTY_DOC(representation, "")
    REFLECTION_PROPERTY_DOC(advanceReduction, "reduces advance for non-monospace font. It also assumes that glyph box is reduced for monospace display.")
REFLECTION_TYPE_END
//=============================================================================
REFLECTION_TYPE_BEGIN((sg,image,tool), Kerning)
    REFLECTION_TYPE_DOC("")
    REFLECTION_PROPERTY_DOC(character1, "")
    REFLECTION_PROPERTY_DOC(character2, "")
    REFLECTION_PROPERTY_DOC(value, "")
REFLECTION_TYPE_END
//=============================================================================
namespace {
    u32 GetCharFromRepresentation(std::string const& rep)
    {
        if('\\' == rep[0])
        {
            char c = rep[1];
            if('0' <= c && c <= '9')
            {
                size_t i =1;
                u32 val = 0; //c - '0';
                do
                {
                    SG_ASSERT('0' <= c && c <= '9');
                    val *= 10;
                    val += c - '0';
                    c = rep[++i];
                } while('\0' != c);
                SG_ASSERT(i == rep.size());
                return val;
            }
            if('\\' == c)
                return c;
            if('\'' == c)
                return c;
            if('\"' == c)
                return c;
            SG_ASSERT_NOT_REACHED();
            return 0;
        }
        else
        {
            SG_ASSERT(1 == rep.size());
            return u8(rep.back());
        }
    }
}
//'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
void SymbolDictionary::Add(std::string const& iName, size_t iCode)
{
    SG_ASSERT(m_symbolFromCode.end() == m_symbolFromCode.find(iCode));
    SG_ASSERT(m_symbolFromName.end() == m_symbolFromName.find(iName));
    size_t const index = m_symbols.size();
    m_symbolFromCode.insert(std::make_pair(iCode, index));
    m_symbolFromName.insert(std::make_pair(iName, index));
    m_symbols.emplace_back();
    m_symbols.back().code = iCode;
    m_symbols.back().name = iName;
}
//'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
void SymbolDictionary::Dump()
{
    std::ostringstream oss;
    oss << "// This file is automatically generated by FontCodeGenerator." << std::endl;
    oss << "// Please copy it in Image source directory."  << std::endl;
    oss << "#ifndef Image_FontSymbols_H" << std::endl;
    oss << "#define Image_FontSymbols_H" << std::endl;
    oss << std::endl;
    oss << "namespace sg {" << std::endl;
    oss << "namespace image {" << std::endl;
    oss << "namespace symbols {" << std::endl;
    oss << "namespace {" << std::endl;
    std::vector<Symbol> sorted = m_symbols;
    std::sort(sorted.begin(), sorted.end(), [](Symbol const& a, Symbol const& b) { return a.code < b.code;});
    size_t maxLength = 0;
    for(auto const& s : sorted)
        maxLength = std::max(maxLength, s.name.length());
    for(auto const& s : sorted)
        oss << "    size_t const " << std::setw(maxLength) << std::left << s.name << " = " << s.code << ";" << std::endl;
    oss << "}" << std::endl;
    oss << "}" << std::endl;
    oss << "}" << std::endl;
    oss << "}" << std::endl;
    oss << std::endl;
    oss << "#endif" << std::endl;

    FilePath out("tmp:/FontSymbols.h");

#if SG_PLATFORM_IS_WIN
    bool ok = winutils::WriteFileOverwriteIFNROK(out.GetSystemFilePath(), reinterpret_cast<u8 const*>(oss.str().data()), oss.str().size());
    SG_ASSERT(ok);
#else
#error todo
    SG_ASSERT_NOT_IMPLEMENTED();
#endif
}
//'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Font::Font()
    : m_famillyName()
    , m_bold()
    , m_italic()
    , m_advance()
    , m_baseline()
    , m_glyphSize()
    , m_glyphs()
    , m_kernings()
{}
//'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Font::~Font()
{
}
//'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
void Font::GenerateCode(size_t index, std::string& datacode, std::string& fontcode, SymbolDictionary& symbols, size_t& memoryfootprint) const
{
    //==== Glyphs

    size_t const glyphCount = m_glyphs.size();

    u32 maxCharCode = 0;
    std::vector<u32> charCodes;
    std::unordered_map<size_t, size_t> advanceReversePalette;
    std::vector<size_t> sortedGlyphIndices;
    charCodes.reserve(glyphCount);
    sortedGlyphIndices.reserve(glyphCount);
    bool is0defined = false;
    for_range(size_t, i, 0, glyphCount)
    {
        Glyph const& glyph = m_glyphs[i];
        u32 const c32 = GetCharFromRepresentation(glyph.character);
        if(0 == c32) is0defined = true;
        maxCharCode = std::max(maxCharCode, c32);
        size_t const glyphAdvance = m_advance - glyph.advanceReduction;
        SG_ASSERT(glyphAdvance <= 0xFF);
        advanceReversePalette.emplace(glyphAdvance, advanceReversePalette.size());
        charCodes.push_back(c32);
        sortedGlyphIndices.push_back(i);
        if(!glyph.symbol.empty())
            symbols.Add(glyph.symbol, c32);
    }
    SG_ASSERT_MSG(is0defined, "You must provide a representation for unknown character as a glyph for 0.");

    std::sort(sortedGlyphIndices.begin(), sortedGlyphIndices.end(), [&](size_t const& a, size_t const& b) { return charCodes[a] < charCodes[b]; });

    size_t const bitCountPerGlyph = m_glyphSize.x() * m_glyphSize.y();
    size_t const bitCountForGlyphsData = glyphCount * bitCountPerGlyph;
    std::vector<u64> glyphsData((bitCountForGlyphsData + 63) / 64, 0);

    size_t const charCodeSizeInBytes = maxCharCode > 0xFF ? maxCharCode > 0xFFFF ? 4 : 2 : 1;
    std::vector<u8> charCodesData;
    charCodesData.reserve(glyphCount * charCodeSizeInBytes);

    std::vector<u8> advancePalette;
    {
        std::vector<u8> unsortedAdvancePalette(advanceReversePalette.size(), u8(all_ones));
        for(auto it : advanceReversePalette)
        {
            SG_ASSERT(it.second < unsortedAdvancePalette.size());
            unsortedAdvancePalette[it.second] = checked_numcastable(it.first);
        }
        advancePalette = unsortedAdvancePalette;
        std::sort(advancePalette.begin(), advancePalette.end(), [&](size_t a, size_t b) { return a > b; });
        for(auto& it : advanceReversePalette)
        {
            bool found = false;
            for_range(size_t, i, 0, unsortedAdvancePalette.size())
            {
                if(advancePalette[i] == unsortedAdvancePalette[it.second])
                {
                    found = true;
                    it.second = i;
                    break;
                }
            }
            SG_ASSERT(found);
        }
    }

    size_t advanceBitCount = 0;
    {
        size_t const availableBitCounts[] = {0,1,2,4, size_t(-1)};
        for_range(size_t, i, 0, SG_ARRAYSIZE(availableBitCounts))
        {
            advanceBitCount = availableBitCounts[i];
            if((size_t(1) << advanceBitCount) >= advanceReversePalette.size())
                break;
        }
        SG_ASSERT(advanceBitCount != -1);
    }
    std::vector<u64> advancesData((advanceBitCount * glyphCount + 63) / 64, 0);

    SG_CODE_FOR_ASSERT(u32 prevCharCode_ForAssert = all_ones);
    for_range(size_t, i, 0, glyphCount)
    {
        size_t const glyphIndex = sortedGlyphIndices[i];
        Glyph const& glyph = m_glyphs[glyphIndex];
        u32 const c32 = charCodes[glyphIndex];
        SG_ASSERT_MSG(prevCharCode_ForAssert != c32, "A char code is present multiple times");
        SG_CODE_FOR_ASSERT(prevCharCode_ForAssert = c32);
        for_range(size_t, b, 0, charCodeSizeInBytes)
        {
            u8 const byte = (c32 >> ((charCodeSizeInBytes-b-1) * 8)) & 0xFF;
            charCodesData.push_back(byte);
        }
        SG_ASSERT(size_t((1 << bitCountPerGlyph) - 1) >= c32);
        size_t const glyphDataOffset = i * bitCountPerGlyph;
        std::vector<bool> glyphBits;
        glyphBits.reserve(bitCountPerGlyph);
        for(auto b : glyph.representation)
        {
            if('.' == b || '0' == b)
                glyphBits.push_back(false);
            else if('X' == b || '1' == b)
                glyphBits.push_back(true);
        }
        SG_ASSERT(glyphBits.size() == bitCountPerGlyph);
        for_range(size_t, j, 0, bitCountPerGlyph)
        {
            SG_ASSERT(((glyphDataOffset + j) >> 6) < glyphsData.size());
            size_t const addressMask = (1 << 6) - 1;
            if(glyphBits[j])
                glyphsData[(glyphDataOffset + j) >> 6] |= u64(1) << ((glyphDataOffset + j) & addressMask);
        }
        if(0 != advanceBitCount)
        {
            size_t glyphAdvance = m_advance - glyph.advanceReduction;
            auto f = advanceReversePalette.find(glyphAdvance);
            SG_ASSERT(f != advanceReversePalette.end());
            size_t const glyphAdvanceIndex = f->second;
            size_t const address = i * advanceBitCount;
            SG_ASSERT(size_t(size_t(1) << advanceBitCount) > glyphAdvanceIndex);
            size_t const addressMask = (1 << 6) - 1;
            advancesData[address >> 6] |= (u64(glyphAdvanceIndex) << u64(address & addressMask));
        }
    }

    //==== Kernings

    size_t const kerningCount = m_kernings.size();
    std::vector<u64> kerningCharCodes;
    std::vector<int> kerningValues;
    std::unordered_map<size_t, size_t> kerningReversePalette;
    std::vector<size_t> sortedKerningIndices;
    kerningCharCodes.reserve(kerningCount);
    kerningValues.reserve(kerningCount);
    sortedKerningIndices.reserve(kerningCount);
    for_range(size_t, i, 0, kerningCount)
    {
        Kerning const& kerning = m_kernings[i];
        SG_ASSERT(0 != kerning.value);
        if(0 == kerning.value) { continue; }
        u32 const c32_1 = GetCharFromRepresentation(kerning.character1);
        u32 const c32_2 = GetCharFromRepresentation(kerning.character2);
        SG_ASSERT(c32_1 <= maxCharCode);
        SG_ASSERT(c32_2 <= maxCharCode);
        u64 const kerningCharCode = u64(c32_2) | (u64(c32_1) << 32);
        kerningCharCodes.push_back(kerningCharCode);
        kerningValues.push_back(kerning.value);
        sortedKerningIndices.push_back(i);
        kerningReversePalette.emplace(kerning.value, kerningReversePalette.size());
    }

    std::sort(sortedKerningIndices.begin(), sortedKerningIndices.end(), [&](size_t const& a, size_t const& b) { return kerningCharCodes[a] < kerningCharCodes[b]; });

    std::vector<i8> kerningPalette;
    {
        std::vector<i8> unsortedKerningPalette(kerningReversePalette.size(), -1);
        for(auto it : kerningReversePalette)
        {
            SG_ASSERT(it.second < unsortedKerningPalette.size());
            unsortedKerningPalette[it.second] = checked_numcastable(it.first);
        }
        kerningPalette = unsortedKerningPalette;
        std::sort(kerningPalette.begin(), kerningPalette.end(), [&](i8 a, i8 b) { return a > b; });
        for(auto& it : kerningReversePalette)
        {
            bool found = false;
            for_range(size_t, i, 0, kerningPalette.size())
            {
                if(kerningPalette[i] == unsortedKerningPalette[it.second])
                {
                    found = true;
                    it.second = i;
                    break;
                }
            }
            SG_ASSERT(found);
        }
    }

    size_t kerningBitCount = 0;
    {
        size_t const availableBitCounts[] = {0,1,2, size_t(-1)};
        for_range(size_t, i, 0, SG_ARRAYSIZE(availableBitCounts))
        {
            kerningBitCount = availableBitCounts[i];
            if(size_t(1) << kerningBitCount >= kerningReversePalette.size())
                break;
        }
        SG_ASSERT(kerningBitCount != -1);
    }
    std::vector<u64> kerningsData((kerningBitCount * kerningCount + 63) / 64, 0);

    std::vector<u8> kerningCharCodesData;
    kerningCharCodesData.reserve(kerningCount * 2 * charCodeSizeInBytes);

    SG_CODE_FOR_ASSERT(u64 prevCharCodePair_ForAssert = all_ones);
    for_range(size_t, i, 0, kerningCount)
    {
        size_t const sortedKerningIndex = sortedKerningIndices[i];
        //Kerning const& glyph = m_glyphs[glyphIndex];
        u64 const charCodePair64 = kerningCharCodes[sortedKerningIndex];
        SG_ASSERT_MSG(prevCharCodePair_ForAssert != charCodePair64, "A char code is present multiple times");
        SG_ASSERT(prevCharCodePair_ForAssert < charCodePair64 || -1 == prevCharCodePair_ForAssert);
        SG_CODE_FOR_ASSERT(prevCharCodePair_ForAssert = charCodePair64);
        for_range(size_t, b, 0, charCodeSizeInBytes)
        {
            u8 const byte = (charCodePair64 >> ((charCodeSizeInBytes-b-1) * 8 + 32)) & 0xFF;
            kerningCharCodesData.push_back(byte);
        }
        for_range(size_t, b, 0, charCodeSizeInBytes)
        {
            u8 const byte = (charCodePair64 >> ((charCodeSizeInBytes-b-1) * 8)) & 0xFF;
            kerningCharCodesData.push_back(byte);
        }
        if(0 != kerningBitCount)
        {
            size_t kerning = kerningValues[sortedKerningIndices[i]];
            auto f = kerningReversePalette.find(kerning);
            SG_ASSERT(f != kerningReversePalette.end());
            size_t const kerningIndex = f->second;
            size_t const address = i * kerningBitCount;
            SG_ASSERT(size_t(size_t(1) << kerningBitCount) > kerningIndex);
            size_t const addressMask = (1 << 6) - 1;
            kerningsData[address >> 6] |= (u64(kerningIndex) << u64(address & addressMask));
        }
    }

    //==== Print

    std::ostringstream ossdata;
    std::ostringstream ossfont;
    memoryfootprint = 0;

    {
        size_t const cutAt = 32;
        ossdata << "u8 const fontCharCodes_" << index << " [] = {" << std::endl;
        ossdata << "    ";
        for_range(size_t, i, 0, charCodesData.size())
        {
            ossdata << "0x";
            ossdata << std::hex << std::setfill('0') << std::right << std::setw(2*sizeof(u8));
            ossdata << (int)charCodesData[i];
            ossdata << std::dec;
            if(cutAt-1 == i % cutAt)
            {
                ossdata << "," << std::endl;
                if(charCodesData.size() - 1 != i)
                    ossdata << "    ";
            }
            else
            {
                ossdata << ",";
                if(charCodesData.size() - 1 == i)
                    ossdata << std::endl;
            }
        }
        ossdata << "};" << std::endl;
        size_t const memsize = charCodesData.size() * sizeof(u8);
        ossdata << "static_assert(sizeof(fontCharCodes_" << index << ") == " << memsize << ", \"\");" << std::endl;
        memoryfootprint += memsize;
    }
    {
        size_t const cutAt = 8;
        ossdata << "u64 const fontGlyphsData_" << index << " [] = {" << std::endl;
        ossdata << "    ";
        for_range(size_t, i, 0, glyphsData.size())
        {
            ossdata << "0x";
            ossdata << std::hex << std::setfill('0') << std::right << std::setw(2*sizeof(u64));
            ossdata << glyphsData[i];
            ossdata << std::dec;
            if(cutAt-1 == i % cutAt)
            {
                ossdata << "," << std::endl;
                if(glyphsData.size() - 1 != i)
                    ossdata << "    ";
            }
            else
            {
                ossdata << ",";
                if(glyphsData.size() - 1 == i)
                    ossdata << std::endl;
                else
                    ossdata << " ";
            }
        }
        ossdata << "};" << std::endl;
        size_t const memsize = glyphsData.size() * sizeof(u64);
        ossdata << "static_assert(sizeof(fontGlyphsData_" << index << ") == " << memsize << ", \"\");" << std::endl;
        memoryfootprint += memsize;
    }
    if(0 != advanceBitCount)
    {
        size_t const cutAt = 8;
        ossdata << "u64 const fontAdvancesData_" << index << " [] = {" << std::endl;
        ossdata << "    ";
        for_range(size_t, i, 0, advancesData.size())
        {
            ossdata << "0x";
            ossdata << std::hex << std::setfill('0') << std::right << std::setw(2*sizeof(u64));
            ossdata << advancesData[i];
            ossdata << std::dec;
            if(cutAt-1 == i % cutAt)
            {
                ossdata << "," << std::endl;
                if(advancesData.size() - 1 != i)
                    ossdata << "    ";
            }
            else
            {
                ossdata << ",";
                if(advancesData.size() - 1 == i)
                    ossdata << std::endl;
                else
                    ossdata << " ";
            }
        }
        ossdata << "};" << std::endl;
        size_t const memsize = advancesData.size() * sizeof(u64);
        ossdata << "static_assert(sizeof(fontAdvancesData_" << index << ") == " << memsize << ", \"\");" << std::endl;
        memoryfootprint += memsize;
    }
    if(0 != kerningCount)
    {
        size_t const cutAt = 32;
        ossdata << "u8 const fontKerningCharCodes_" << index << " [] = {" << std::endl;
        ossdata << "    ";
        for_range(size_t, i, 0, kerningCharCodesData.size())
        {
            ossdata << "0x";
            ossdata << std::hex << std::setfill('0') << std::right << std::setw(2*sizeof(u8));
            ossdata << (int)kerningCharCodesData[i];
            ossdata << std::dec;
            if(cutAt-1 == i % cutAt)
            {
                ossdata << "," << std::endl;
                if(kerningCharCodesData.size() - 1 != i)
                    ossdata << "    ";
            }
            else
            {
                ossdata << ",";
                if(kerningCharCodesData.size() - 1 == i)
                    ossdata << std::endl;
            }
        }
        ossdata << "};" << std::endl;
        size_t const memsize = kerningCharCodesData.size() * sizeof(u8);
        ossdata << "static_assert(sizeof(fontKerningCharCodes_" << index << ") == " << memsize << ", \"\");" << std::endl;
        memoryfootprint += memsize;
    }
    if(0 != kerningBitCount)
    {
        size_t const cutAt = 8;
        ossdata << "u64 const fontKerningData_" << index << " [] = {" << std::endl;
        ossdata << "    ";
        for_range(size_t, i, 0, kerningsData.size())
        {
            ossdata << "0x";
            ossdata << std::hex << std::setfill('0') << std::right << std::setw(2*sizeof(u64));
            ossdata << kerningsData[i];
            ossdata << std::dec;
            if(cutAt-1 == i % cutAt)
            {
                ossdata << "," << std::endl;
                if(kerningsData.size() - 1 != i)
                    ossdata << "    ";
            }
            else
            {
                ossdata << ",";
                if(kerningsData.size() - 1 == i)
                    ossdata << std::endl;
                else
                    ossdata << " ";
            }
        }
        ossdata << "};" << std::endl;
        size_t const memsize = kerningsData.size() * sizeof(u64);
        ossdata << "static_assert(sizeof(fontKerningData_" << index << ") == " << memsize << ", \"\");" << std::endl;
        memoryfootprint += memsize;
    }

    memoryfootprint += sizeof(BitMapFont);

    u8 const advanceForMonospace = checked_numcastable(m_advance);
    u8 const baseAdvance = checked_numcastable(m_advance);
    u8 const baseline = checked_numcastable(m_baseline);
    u32 flags = 0;
    if(m_bold) { flags |= BitMapFont::Flag::Bold; };
    if(m_italic) { flags |= BitMapFont::Flag::Italic; };

    ossfont << "{ ";
    ossfont << "\"" << m_famillyName << "\", ";
    ossfont << glyphCount << ", ";
    ossfont << kerningCount << ", ";
    ossfont << "ubyte2(" << m_glyphSize.x() << ", " << m_glyphSize.y() << "), ";
    ossfont << (int)flags << ", ";
    ossfont << (int)m_advance << ", ";
    ossfont << (int)baseline << ", ";
    ossfont << (int)charCodeSizeInBytes << ", ";
    ossfont << (int)advanceBitCount << ", ";
    ossfont << (int)kerningBitCount << ", ";
    ossfont << "{";
    for(size_t v : advancePalette)
    {
        SG_ASSERT(v <= std::numeric_limits<u8>::max());
        ossfont << v << ",";
    }
    ossfont << "}, ";
    ossfont << "{";
    for(int v : kerningPalette)
    {
        SG_ASSERT(std::numeric_limits<i8>::min() <= v);
        SG_ASSERT(v <= std::numeric_limits<i8>::max());
        ossfont << v << ",";
    }
    ossfont << "}, ";
    ossfont << "fontCharCodes_" << index << ", ";
    ossfont << "fontGlyphsData_" << index << ", ";
    if(0 != advanceBitCount) { ossfont << "fontAdvancesData_" << index; } else {ossfont << "nullptr";} ossfont << ", ";
    if(0 != kerningCount) { ossfont << "fontKerningCharCodes_" << index; } else {ossfont << "nullptr";} ossfont << ", ";
    if(0 != kerningBitCount) { ossfont << "fontKerningData_" << index; } else {ossfont << "nullptr";}
    ossfont << " SG_CODE_FOR_ASSERT(";
    ossfont << " SG_COMMA SG_ARRAYSIZE(fontCharCodes_" << index << ")";
    ossfont << " SG_COMMA SG_ARRAYSIZE(fontGlyphsData_" << index << ")";
    ossfont << " SG_COMMA "; if(0 != advanceBitCount) { ossfont << "SG_ARRAYSIZE(fontAdvancesData_" << index << ")"; } else {ossfont << "0";}
    ossfont << " SG_COMMA "; if(0 != kerningCount) { ossfont << "SG_ARRAYSIZE(fontKerningCharCodes_" << index << ")"; } else {ossfont << "0";}
    ossfont << " SG_COMMA "; if(0 != kerningBitCount) { ossfont << "SG_ARRAYSIZE(fontKerningData_" << index << ")"; } else {ossfont << "0";}
    ossfont << " ) }";
    datacode = ossdata.str();
    fontcode = ossfont.str();
}
//'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
REFLECTION_CLASS_BEGIN((sg,image,tool), Font)
    REFLECTION_CLASS_DOC("")
    REFLECTION_m_PROPERTY_DOC(famillyName, "")
    REFLECTION_m_PROPERTY_DOC(bold, "")
    REFLECTION_m_PROPERTY_DOC(italic, "")
    REFLECTION_m_PROPERTY_DOC(advance, "")
    REFLECTION_m_PROPERTY_DOC(baseline, "")
    REFLECTION_m_PROPERTY_DOC(glyphSize, "")
    REFLECTION_m_PROPERTY_DOC(glyphs, "")
    REFLECTION_m_PROPERTY_DOC(kernings, "")
REFLECTION_CLASS_END
//=============================================================================
FontCodeGenerator::FontCodeGenerator()
{}
//'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
FontCodeGenerator::~FontCodeGenerator()
{
}
//'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
void FontCodeGenerator::Run() const
{
    SymbolDictionary symbols;
    std::ostringstream oss;
    std::ostringstream ossfont;
    oss << "// This file is automatically generated by FontCodeGenerator." << std::endl;
    oss << "// Please copy it in Image source directory." << std::endl;
    oss << "#include \"stdafx.h\"" << std::endl;
    oss << "#include \"BitMapFont.h\"" << std::endl;
    oss << "#include <Core/Assert.h>" << std::endl;
    oss << "#include <Core/ArrayView.h>" << std::endl;
    oss << "#include <Core/Utils.h>" << std::endl;
    oss << std::endl;
    oss << "namespace sg {" << std::endl;
    oss << "namespace image {" << std::endl;
    oss << "//=============================================================================" << std::endl;
    oss << "namespace {" << std::endl;
    oss << "//=============================================================================" << std::endl;
    size_t memoryfootprint = 0;
    for_range(size_t, i, 0, m_fonts.size())
    {
        FilePath f = m_fonts[i];
        reflection::ObjectDatabase db;
        objectscript::ErrorHandler errorHandler;
        bool ok = objectscript::ReadObjectScriptROK(f, db, errorHandler);
        if(!ok)
            SG_LOG_DEFAULT_DEBUG(errorHandler.GetErrorMessage().c_str());
        SG_ASSERT(ok);

        reflection::ObjectDatabase::named_object_list namedObjects;
        db.GetExportedObjects(namedObjects);

        reflection::BaseClass const* bc = db.GetIFP(reflection::Identifier("::font"));
        SG_ASSERT(nullptr != bc);
        SG_ASSERT(bc->GetMetaclass() == Font::StaticGetMetaclass());
        Font const* font = checked_cast<Font const*>(bc);

        std::string datacode, fontcode;
        size_t fontfootprint = 0;
        font->GenerateCode(i, datacode, fontcode, symbols, fontfootprint);
        memoryfootprint += fontfootprint;
        oss << datacode << std::endl;
        ossfont << "    " << fontcode << ",";
        ossfont << " // " << fontfootprint << " Bytes";
        ossfont << std::endl;
    }
    oss << "//=============================================================================" << std::endl;
    oss << "// Total memory footprint: " << memoryfootprint << " Bytes" << std::endl;
    oss << "BitMapFont const fonts [] = {" << std::endl;
    oss << ossfont.str();
    oss << "};" << std::endl;
    oss << "size_t const fontCount = SG_ARRAYSIZE(fonts);" << std::endl;
    oss << "//=============================================================================" << std::endl;
    oss << "}" << std::endl;
    oss << "//=============================================================================" << std::endl;
    oss << "ArrayView<BitMapFont const> GetAlwaysAvailableBitmapFonts()" << std::endl;
    oss << "{" << std::endl;
    oss << "    return AsArrayView(fonts);" << std::endl;
    oss << "}" << std::endl;
    oss << "//=============================================================================" << std::endl;
    oss << "}" << std::endl;
    oss << "}" << std::endl;

    FilePath out("tmp:/BitMapFontData.cpp");

#if SG_PLATFORM_IS_WIN
#if 1
    bool ok = winutils::WriteFileOverwriteIFNROK(out.GetSystemFilePath(), reinterpret_cast<u8 const*>(oss.str().data()), oss.str().size());
    SG_ASSERT(ok);
#else
    HANDLE handle = CreateFileW(
        ConvertUTF8ToUCS2(out.GetSystemFilePath()).c_str(),
        GENERIC_WRITE,
        0,
        NULL, // Security Attributes
        CREATE_ALWAYS, // Creation Disposition
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS, // Flags and Attributes
        NULL // Template File
        );
    SG_ASSERT(INVALID_HANDLE_VALUE != handle);
    if(INVALID_HANDLE_VALUE == handle)
        return;

    DWORD writtenByteCount = 0;
    BOOL rc = WriteFile(
        handle,
        oss.str().data(),
        checked_numcastable(oss.str().size()),
        &writtenByteCount,
        NULL
        );
    SG_ASSERT(rc);

    CloseHandle(handle);
#endif
#else
#error "TODO"
#endif

    symbols.Dump();
}
//'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
REFLECTION_CLASS_BEGIN((sg,image,tool), FontCodeGenerator)
    REFLECTION_CLASS_DOC("")
    REFLECTION_m_PROPERTY_DOC(fonts, "")
REFLECTION_CLASS_END
//=============================================================================
void GenerateFontCodes()
{
    reflection::ObjectDatabase db;
    objectscript::ErrorHandler errorHandler;
    bool ok = objectscript::ReadObjectScriptWithRetryROK(FilePath("data:/Applications/BitmapFonts/Fonts.os"), db, errorHandler);
    SG_LOG_DEFAULT_DEBUG(errorHandler.GetErrorMessage().c_str());
    SG_ASSERT(ok);

    reflection::ObjectDatabase::named_object_list namedObjects;
    db.GetExportedObjects(namedObjects);

    reflection::BaseClass const* bc = db.GetIFP(reflection::Identifier("::fonts"));
    SG_ASSERT(nullptr != bc);
    SG_ASSERT(bc->GetMetaclass() == FontCodeGenerator::StaticGetMetaclass());
    FontCodeGenerator const* generator = checked_cast<FontCodeGenerator const*>(bc);

    generator->Run();
}
//=============================================================================
}
}
}
#endif
